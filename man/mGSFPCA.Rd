% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mGSFPCA.R
\name{mGSFPCA}
\alias{mGSFPCA}
\title{Estimate Functional Principal Components from Sparse Data}
\usage{
mGSFPCA(
  data,
  p = 2:5,
  k = c(5, 10, 15),
  basis_type = "bspline",
  maxit = 500,
  optim_tol = 1e-05,
  optim_trace = 0,
  nRegGrid = 51,
  init_coeff = NULL,
  obs_range = NULL,
  mu_nbasis = 15,
  bin_size = 51,
  use_kp_grid = TRUE,
  skip_check = FALSE
)
}
\arguments{
\item{data}{A matrix or data frame with three columns: ID (subject ID),
time (observation time points), and value (observed values).}

\item{p}{Integer vector specifying the candidate number of principal
components to consider. Default is 2:5.}

\item{k}{Integer vector specifying the candidate number of basis functions to
consider. Default is c(5, 10, 15).}

\item{basis_type}{Character string specifying the type of basis functions to
use. Options are "bspline" (default) or "fourier".}

\item{maxit}{Integer specifying the maximum number of iterations for the
optimization algorithm. Default is 500.}

\item{optim_tol}{Numeric specifying the relative tolerance for the
optimization convergence (Based on optim()). Default is 1e-5.}

\item{optim_trace}{Integer specifying the level of tracing information from
the optimization algorithm (Based on optim()). Default is 0 (no tracing).}

\item{nRegGrid}{Integer specifying the number of points in the regular grid
for evaluation. Default is 51.}

\item{init_coeff}{Numeric vector of initial coefficients for optimization.
If NULL (default), coefficients are initialized randomly.}

\item{obs_range}{Numeric vector of length 2 specifying the observation range
(aT, bT). If NULL (default), it is set to c(0,1).}

\item{mu_nbasis}{Integer specifying the number of basis functions for the
mean function. Default is 15.}

\item{bin_size}{Integer specifying the number of bins for data binning.
Default is 51.}

\item{use_kp_grid}{Logical indicating whether to evaluate all combinations of
p and k (TRUE, default) or use a stepwise model selection approach (FALSE).}

\item{skip_check}{Logical indicating whether to skip input validation checks.
Default is FALSE.}
}
\value{
A list containing the following components:
\itemize{
\item \code{Phi}: Matrix of estimated eigenfunctions.
\item \code{Lambda}: Vector of estimated eigenvalues.
\item \code{mu}: Vector of the estimated mean function evaluated on the grid.
\item \code{sig2}: Estimated variance of the error term.
\item \code{pars}: A list containing model parameters and results:
\itemize{
\item \code{p}: Optimal number of principal components.
\item \code{k}: Optimal number of basis functions.
\item \code{AIC}: Table of AIC values for different p and k combinations.
\item \code{coeffs}: Optimized coefficients.
\item \code{mu_fdobj}: Functional data object for the mean function.
\item \code{mu_basis}: Basis object for the mean function.
\item \code{workGrid}: Grid points used for estimation.
\item \code{evalGrid}: Evaluation grid points.
\item \code{eigBasis}: Basis object for the eigenfunctions.
\item \code{binData}: Binned data used for estimation.
\item \code{range}: Observation range.
\item \code{convergence}: Convergence status of the optimization
(Based on optim()).
}
}
}
\description{
Functional principal component analysis with modified Gram-Schmidt
Orthornormalization and MLE.
}
\details{
The mGSFPCA function implements functional principal component analysis using
MLE with modified Gram-Schmidt orthornormalization.
}
\examples{
# Plot 3 random subjects
set.seed(111)
samp <- sample.int(100, 3)
# bspline_sim is automatically loaded
Y <- bspline_sim$Y; X <- bspline_sim$X
id <- unique(Y[,1])
grid <- seq(0, 1, length = 51)

plot(Y[,2], Y[,3], type = 'n', ylab = 'Y(t)', xlab = 't')
for (i in 1:3) {
  points(Y[id == samp[i], 2], Y[id == samp[i], 3], col = i, pch = 19)
  lines(grid, X[samp[i], ], col = i, lwd = 2)
}

# Estimate
fit <- mGSFPCA(Y, p = 3:5, k = c(5, 10, 15), basis_type = "bspline",
nRegGrid = 51, bin_size = 101)

c(fit$pars$p, fit$pars$k)

fit$Lambda

plot(grid, fit$Phi[,1], type ='l', lty = 2)
lines(grid, bspline_sim$eigFun[1,], col = 2) # change sign if needed
min(Metrics::rmse(fit$Phi[,1], bspline_sim$eigFun[1,]),
 Metrics::rmse(-fit$Phi[,1], bspline_sim$eigFun[1,]))

x_pred <- get_xHat(fit)
Metrics::rmse(x_pred$xHat, bspline_sim$X)


}
\references{
Peng, J. and Paul, D. (2009). A geometric approach to maximum likelihood
estimation of the functional principal components from sparse longitudinal
data. Journal of Computational and Graphical Statistics.

Yao, F., Müller, H.-G., & Wang, J.-L. (2005). Functional data analysis for
sparse longitudinal data. Journal of the American Statistical Association,
100(470), 577–590.
}
